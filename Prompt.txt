Create a full-featured, interactive Sorting and Pathfinding Algorithm Visualizer built with Vite + React (JavaScript), styled using Tailwind CSS and DaisyUI, with full theme switching capabilities and a clean, modern UI. The application should support visualization and comparison of 20 algorithms in total, including 10 sorting algorithms (Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort, Radix Sort, Counting Sort, Bucket Sort, and Tim Sort) and 10 pathfinding algorithms (Dijkstra’s, A*, BFS, DFS, Bellman-Ford, Floyd-Warshall, Greedy Best-First Search, IDDFS, Uniform Cost Search, and Jump Point Search). For sorting, users must be able to adjust the number of sorting elements between 10 and 100, randomize the array, adjust the visualization speed, and compare two sorting algorithms side-by-side, each displayed with animated bars that change dynamically during comparisons, swaps, and final sorting. Every sorting algorithm should include a theory panel explaining its concept, pseudocode, formulas, best/average/worst-case time complexities, space complexity, algorithmic properties (stable/unstable, comparison-based/non-comparison), and a summary of typical use cases. Real-time performance metrics such as number of comparisons, swaps, passes, and total execution steps should be visualized numerically and graphically. For pathfinding, users must be able to set the maze/grid size (10×10 up to 50×50), choose start and end points, draw or erase obstacles, generate randomized mazes, and adjust animation speed. Both algorithms selected for comparison should run simultaneously on two separate grids, clearly visualizing open nodes, closed nodes, visited nodes, frontier sets, shortest paths, and algorithm exploration patterns. Each pathfinding algorithm must also include a rich theory section containing algorithm descriptions, heuristics (e.g., for A*), formulas, pseudocode, best/average/worst time complexities, space complexity, and usage scenarios (e.g., weighted graphs, grids, negative edges, shortest paths vs. optimal paths). Users must be able to pause, resume, step forward, continue execution, or fully restart simulations for both sorting and pathfinding modes. The UI should feature dedicated panels for algorithm selection, speed control, input configuration, comparison mode, visualization area, and the theory/info panel. Include a theme switcher powered by DaisyUI supporting light, dark, and several additional themes. Implement optional enhancements such as performance graphs, a summary comparing algorithm efficiency after execution, an educational mode explaining each visual step in real time, and accessibility features like keyboard navigation and high-contrast themes. The entire project should be optimized for smooth rendering even at high element counts or large grid sizes, using animation-friendly libraries (React Spring, Framer Motion) where appropriate. Overall, the final system should function as an advanced, educational, visually appealing, and deeply interactive platform that allows users to fully understand, explore, and compare sorting techniques and pathfinding strategies in a highly intuitive and engaging way.